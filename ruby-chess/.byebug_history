exit
row
row.first
piece
row
c
piece.pos
piece
c
piece
j
i
ci
c
cc
c
cc
c
row
row.unshift("a")
row
exit
c
exit
self.grid[1][6]
self.grid[2][6]
self.grid[2][6].class
s
display position
s
display el
s
directions
s
self.grid[1][6]
self.grid[2][6]
self.class
king_piece.pos
piece.possible_moves
display piece.color
s
king_piece.pos
s
piece.color
s
piece.color
s
piece.color
s
color
piece.color
s
n
s
n
c
s
display piece.pos
display piece.class
display piece
s
n
s
n
c
n
piece
s
n
color
s
dup_board.check?(:black)
d.render
d.build_grid
d
d = Display.new(dup_board)
self
d = Display.new
n
end_pos
moving_piece.pos
n
s
end_pos
moving_piece.class
moved_into_check?(moving_piece, end_pos)
n
end_pos
n
valid_move?([2,6])
move_arr
c
exit
c
valid_move?(position)
position
c
opposing_pieces
c
opposing_pieces
piece.class
c
n
c
moving_piece
possible_moves
n
position
self.class
n
self.class
n
self.color
c
n
display position
position
n
self.color
possible_moves
n
kills?(position)
self.class
self
possible_moves
position
c
self.grid[2][6]
c
exit
self.grid
self.board.grid[2][6]
self.grid[2][6]
self
valid_move?(position)
c
exit
kills?(position)
kills(position)
position
@grid[2][6]
@grid[2, 6]
self.pos
self
c
cc
c
cc
c
cc
c
cc
c
self
c
s
self
s
opposing_pieces.each do |piece| puts ("#{piece.class}, #{piece.pos}") end
opposing_pieces.each do |piece| puts piece.class piece.pos end
opposing_pieces.each do |piece| puts piece.class puts piece.pos end
opposing_pieces.each do |piece| puts piece.class end
opposing_pieces.each do |piece| puts piece.color end
opposing_pieces.each do |piece| puts piece.color
opposing_pieces.length
opposing_pieces[3].color
opposing_pieces.second.color
opposing_pieces.first.color
opposing_pieces
n
s
dup_board.check?(:black)
dup_board.grid[end_pos[0]][end_pos[1]]
dup_board.grid[end_pos[0]][endpos[1]]
dup_board.grid[moving_piece.pos[0]][moving_piece.pos[1]]
n
s
c
s
@grid[xstart][ystart]
moved_piece.pos
s
@grid[xend][yend]
s
moved_piece.pos
end_pos
moved_piece.pos
moved_piece
s
self
end_pos
start_pos
s
n
s
c
n
s
c
exit
end_pos
moving_piece.pos
moving_piece
dup_board.check?(moving_piece.color)
s
d.render
d.build_grid
d = Display.new(dup_board)
dup_board
sup_board
n
s
moved_into_check?(moving_piece, end_pos)
moving_piece
c
moved_into_check?(moving_piece, end_pos)
c
exit
moving_piece.opposite_color
check?(:white)
check?(:black)
n
end_pos
end_os
moving_piece.pos
n
@grid[end_row][end_col]
n
moved_into_check?(moving_piece, end_pos)
n
possible_moves.include?(end_pos)
end_pos
possible_moves
moving_piece.pos
moving_piece
moving_piece.color
exit
moving_piece.color
c
moving_piece
n
exit
@grid[start_row][start_col]
start
moving_piece
c
opposite_color
@color
n
possible_moves
end_pos
n
s
move
s
@grid[x][y].color
